<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Cours ASA ‚Äì R√©vision</title>
  <link rel="icon" type="image/png" sizes="192x192" href="./icon-192.png?v=10">
<link rel="icon" type="image/png" sizes="512x512" href="./icon-512.png?v=10">
  <link rel="apple-touch-icon" href="./icon-192.png?v=10">
<link rel="apple-touch-icon" sizes="192x192" href="./icon-192.png?v=10">
  <style>
    :root{
      --bg:#0f1220; --card:#171a2b; --txt:#e9ecff; --muted:#9aa3ff;
      --good:#2ecc71; --bad:#ff6b6b; --primary:#5b7cff; --panel:#121826;
      --shadow:0 10px 30px rgba(0,0,0,.35);
      --gold:#f5b942;
    }
    *{box-sizing:border-box}
    html,body{height:100%; margin:0;}
    body{
      font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu;
      background:linear-gradient(180deg,#0b0e1a,#0f1220);
      color:var(--txt);
      overflow:hidden; /* iPhone: scroll only in main */
    }

    /* iPhone/Safari viewport */
    .app{
      height:100dvh;
      display:flex;
      flex-direction:column;
      padding:12px 12px 0 12px;
    }
    @supports (-webkit-touch-callout:none){
      .app{ height:-webkit-fill-available; }
    }

    /* Top bar (sticky) */
    .topbar{
      position:sticky; top:0;
      display:flex;
      gap:10px;
      align-items:center;
      flex-wrap:wrap;
      margin-bottom:10px;
      padding-bottom:8px;
      z-index:10;
      backdrop-filter: blur(10px);
    }
    .pill{
      background:rgba(255,255,255,.06);
      border:1px solid rgba(255,255,255,.12);
      color:var(--txt);
      padding:8px 10px;
      border-radius:999px;
      font-weight:800;
      font-size:12px;
      line-height:1;
      white-space:nowrap;
    }
    .pill.muted{ color:var(--muted); font-weight:700; }
    .btn{
      background:rgba(255,255,255,.06);
      color:var(--txt);
      border:1px solid rgba(255,255,255,.12);
      padding:10px 12px;
      border-radius:14px;
      font-weight:800;
      font-size:13px;
      cursor:pointer;
      touch-action:manipulation;
    }
    .btn:active{ transform:scale(.99); }
    select{
      background:#0b0e1a;
      color:var(--txt);
      border-radius:14px;
      padding:10px 12px;
      border:1px solid rgba(255,255,255,.15);
      font-weight:800;
      font-size:13px;
      max-width: 100%;
    }

    /* Main scroll area */
    main{
      flex:1;
      overflow:auto;
      -webkit-overflow-scrolling:touch;
      padding-bottom: calc(190px + env(safe-area-inset-bottom)); /* keep above panel */
    }

    .card{
      background:var(--card);
      border-radius:18px;
      box-shadow:var(--shadow);
      padding:16px;
    }
    .q{font-size:1.25rem; font-weight:900; margin:0 0 10px 0; line-height:1.25}
    .a{white-space:pre-wrap; margin-top:10px; color:rgba(233,236,255,.92); line-height:1.35}
    .img{width:100%; height:auto; border-radius:14px; margin-top:12px; box-shadow:var(--shadow)}
    .hint{color:var(--muted); font-size:.9rem; margin-top:10px}

    /* Bottom panel fixed */
    .panel{
      position:fixed;
      left:0; right:0; bottom:0;
      background:var(--panel);
      padding:12px 12px;
      padding-bottom: calc(12px + env(safe-area-inset-bottom));
      border-top-left-radius:22px;
      border-top-right-radius:22px;
      box-shadow:0 -10px 30px rgba(0,0,0,.45);
      display:flex;
      flex-direction:column;
      gap:10px;
      z-index:20;
    }
    .row{display:flex; gap:10px;}
    .actionBtn{
      border:0;
      border-radius:14px;
      padding:12px 14px;
      font-weight:900;
      font-size:16px;
      cursor:pointer;
      touch-action:manipulation;
      color:#fff;
      background:rgba(255,255,255,.10);
      width:100%;
    }
    .actionBtn:active{ transform:scale(.99); }
    button:disabled{ opacity:.45; filter:saturate(.7); }
    .noTap{ pointer-events:none; }

    .primary{background:var(--primary);}
    .good{background:var(--good); color:#052;}
    .bad{background:var(--bad);}
    .gold{background:var(--gold); color:#1b1b1b;}
    .statsLine{
      display:flex; gap:10px; flex-wrap:wrap;
      align-items:center;
      color:var(--muted);
      font-size:.9rem;
      justify-content:space-between;
    }
    .statsLine .right{ margin-left:auto; }

    /* ‚úÖ IMPORTANT: hidden must win over .row { display:flex } */
    .hidden{ display:none !important; }

    /* Desktop: keep your old wider layout */
    @media (min-width: 900px){
      body{ overflow:auto; }
      .app{ max-width: 1200px; margin:0 auto; height:auto; padding:16px; }
      main{ padding-bottom: 0; }
      .panel{ position:static; border-radius:18px; margin-top:14px; }
    }
  </style>
</head>
<body>
  <div class="app">
    <div class="topbar">
      <select id="themeSelect"></select>

      <span class="pill muted">Version contenu: <span id="contentVersion">‚Äî</span></span>
      <span class="pill muted">R√©seau: <span id="offlineLabel">‚Äî</span></span>

      <button class="btn" id="shuffleBtn" title="M√©langer les cartes">üîÄ M√©langer</button>
      <button class="btn" id="reviewWrongBtn" title="Revoir uniquement les cartes fausses">‚õî Revoir les faux</button>
      <button class="btn" id="resetStatsBtn" title="R√©initialiser les cartes fausses">‚ôªÔ∏è R√©initialiser stats</button>
    </div>

    <main>
      <div class="card">
        <div class="q" id="qText">‚Äî</div>
        <img id="qImg" class="img hidden" alt="" />

        <div class="a hidden" id="aText"></div>
        <img id="aImg" class="img hidden" alt="" />

      </div>
    </main>

    <!-- Panel fixe en bas (iPhone) -->
    <div class="panel">
      <div class="statsLine">
        <div id="statsLine">‚Äî</div>
      </div>

      <button class="actionBtn primary" id="showAnswerBtn">üëÅ Voir la r√©ponse</button>

      <div class="row">
        <button class="actionBtn" id="skipBtn" title="Mettre cette question √† la fin">‚è≠ Suivant</button>
      </div>

      <div class="row hidden" id="markRow">
        <button class="actionBtn good" id="justeBtn" disabled>‚úÖ Juste</button>
        <button class="actionBtn bad" id="fauxBtn" disabled>‚ùå Faux</button>
      </div>

      <button class="actionBtn gold hidden" id="finishBtn">üéâ Th√®me termin√© ‚Äì changer de th√®me</button>
    </div>
  </div>

<script>
/*
  Version affich√©e = UNIQUEMENT themes/index.json (champ "version")
  Pas de mode d√©mo.
*/

const $ = (id)=>document.getElementById(id);

const themeSelect = $("themeSelect");
const offlineLabel = $("offlineLabel");
const contentVersion = $("contentVersion");

const qText = $("qText");
const aText = $("aText");
const qImg = $("qImg");
const aImg = $("aImg");

const showAnswerBtn = $("showAnswerBtn");
const skipBtn = $("skipBtn");
const justeBtn = $("justeBtn");
const fauxBtn = $("fauxBtn");
const markRow = $("markRow");
const finishBtn = $("finishBtn");

const statsLine = $("statsLine");
const hintLine = $("hintLine");

const shuffleBtn = $("shuffleBtn");
const reviewWrongBtn = $("reviewWrongBtn");
const resetStatsBtn = $("resetStatsBtn");

let THEMES_INDEX = null;
let appVersion = "0"; // set from themes/index.json version (for cache-bust)
let cards = [];
let fullCards = [];
let currentIndex = 0;
let state = { showAnswer:false };
let currentThemeId = null;
let wrongIds = new Set();
let reviewMode = false;
let doneIds = new Set(); // cards answered (Juste/Faux) in normal mode

function setOfflineLabel(ok){ offlineLabel.textContent = ok ? "ok" : "erreur"; }
function withBust(url){
  // cache-bust based on index.json version (what YOU control)
  return url + (url.includes("?") ? "&" : "?") + "v=" + encodeURIComponent(appVersion);
}

function storageKeyWrong(themeId){ return `asa_wrong_${themeId}`; }
function storageKeyDone(themeId){ return `asa_done_${themeId}`; } // optional persistence (simple)

function loadWrong(themeId){
  try{
    const raw = localStorage.getItem(storageKeyWrong(themeId));
    const arr = raw ? JSON.parse(raw) : [];
    wrongIds = new Set(Array.isArray(arr) ? arr : []);
  }catch(_){ wrongIds = new Set(); }
  updateReviewButtonLabel();
}
function saveWrong(){
  if(!currentThemeId) return;
  localStorage.setItem(storageKeyWrong(currentThemeId), JSON.stringify(Array.from(wrongIds)));
}

function loadDone(themeId){
  try{
    const raw = localStorage.getItem(storageKeyDone(themeId));
    const arr = raw ? JSON.parse(raw) : [];
    doneIds = new Set(Array.isArray(arr) ? arr : []);
  }catch(_){ doneIds = new Set(); }
}
function saveDone(){
  if(!currentThemeId) return;
  localStorage.setItem(storageKeyDone(currentThemeId), JSON.stringify(Array.from(doneIds)));
}

function updateReviewButtonLabel(){
  reviewWrongBtn.textContent = reviewMode ? "‚Ü©Ô∏è Revenir au th√®me" : "‚õî Revoir les faux";
}

function isThemeFinished(){
  if(reviewMode) return false;
  if(!fullCards.length) return false;
  const allHaveId = fullCards.every(c => c && c.id);
  if(allHaveId) return doneIds.size >= fullCards.length;
  return false;
}

function hideMarkRow(){ markRow.classList.add('hidden'); }
function showMarkRow(){ markRow.classList.remove('hidden'); }

function lockMarkButtons(locked){
  justeBtn.disabled = locked;
  fauxBtn.disabled = locked;
  if(locked){ markRow.classList.add('noTap'); }
  else { markRow.classList.remove('noTap'); }
}

function render(){
  if(isThemeFinished()){
    qText.textContent = "‚úÖ Th√®me termin√© !";
    hintLine.textContent = "Tu peux changer de th√®me (bouton en bas) ou revoir les faux.";
    aText.classList.add("hidden"); aText.textContent = "";
    qImg.classList.add("hidden"); qImg.removeAttribute("src");
    aImg.classList.add("hidden"); aImg.removeAttribute("src");

    finishBtn.classList.remove("hidden");
    showAnswerBtn.classList.add("hidden");
    markRow.classList.add("hidden");
    skipBtn.classList.add("hidden");

    statsLine.textContent = `${fullCards.length} / ${fullCards.length} (termin√©)`;
    return;
  } else {
    finishBtn.classList.add("hidden");
    skipBtn.classList.remove("hidden");
  }

  if(!cards.length){
    qText.textContent="Aucune carte.";
    aText.textContent=""; aText.classList.add("hidden");
    qImg.classList.add("hidden"); qImg.removeAttribute("src");
    aImg.classList.add("hidden"); aImg.removeAttribute("src");

    showAnswerBtn.classList.remove("hidden");
    markRow.classList.add("hidden");

    statsLine.textContent="‚Äî";
    hintLine.textContent="";
    return;
  }

  const card = cards[currentIndex];
  qText.textContent = card.q || "";

  if(card.img){
    qImg.src = card.img;
    qImg.classList.remove("hidden");
  }else{
    qImg.classList.add("hidden");
    qImg.removeAttribute("src");
  }

  if(state.showAnswer && card.a && card.a.trim()!==""){
    aText.textContent=card.a;
    aText.classList.remove("hidden");
  }else{
    aText.textContent="";
    aText.classList.add("hidden");
  }

  if(state.showAnswer && card.img_answer){
    aImg.src = card.img_answer;
    aImg.classList.remove("hidden");
  }else{
    aImg.classList.add("hidden");
    aImg.removeAttribute("src");
  }

  // Controls: hide Juste/Faux until answer is shown
  showAnswerBtn.classList.toggle("hidden", state.showAnswer);
  if(state.showAnswer){ showMarkRow(); } else { hideMarkRow(); }
  lockMarkButtons(!state.showAnswer);

  // Stats line
  const base = `${currentIndex+1} / ${cards.length}`;
  if(!reviewMode && fullCards.length){
    const done = doneIds.size;
    statsLine.textContent = `${base} ‚Ä¢ Fait: ${done}/${fullCards.length}`;
  }else{
    statsLine.textContent = base;
  }

}

function next(){
  hideMarkRow();
  lockMarkButtons(true);

  state.showAnswer=false;
  currentIndex = (currentIndex+1) % cards.length;
  render();
}

function shuffleInPlace(arr){
  for(let i=arr.length-1;i>0;i--){
    const j = Math.floor(Math.random()*(i+1));
    [arr[i],arr[j]] = [arr[j],arr[i]];
  }
}

showAnswerBtn.addEventListener("click", ()=>{
  state.showAnswer=true;
  showMarkRow();
  lockMarkButtons(false);
  render();
});

skipBtn.addEventListener("click", ()=>{
  hideMarkRow();
  if(cards.length<=1) return;
  const c = cards.splice(currentIndex,1)[0];
  cards.push(c);
  if(currentIndex >= cards.length) currentIndex = 0;
  state.showAnswer=false;
  lockMarkButtons(true);
  render();
});

function markDoneForCurrentCard(){
  if(reviewMode) return;
  const c = cards[currentIndex];
  if(c && c.id){
    doneIds.add(c.id);
    saveDone();
  }
}

justeBtn.addEventListener("click", ()=>{
  if(!state.showAnswer) return; // ‚úÖ s√©curit√©
  const c = cards[currentIndex];
  if(c && c.id){ wrongIds.delete(c.id); saveWrong(); }
  markDoneForCurrentCard();
  next();
});

fauxBtn.addEventListener("click", ()=>{
  if(!state.showAnswer) return; // ‚úÖ s√©curit√©
  const c = cards[currentIndex];
  if(c && c.id){ wrongIds.add(c.id); saveWrong(); }
  markDoneForCurrentCard();
  next();
});

shuffleBtn.addEventListener("click", ()=>{
  if(!cards.length) return;
  shuffleInPlace(cards);
  currentIndex = 0;
  state.showAnswer = false;
  render();
});

reviewWrongBtn.addEventListener("click", ()=>{
  if(!currentThemeId) return;

  if(reviewMode){
    reviewMode = false;
    cards = fullCards.slice();
    currentIndex = 0;
    state.showAnswer = false;
    updateReviewButtonLabel();
    render();
    return;
  }

  const list = fullCards.filter(c => c && c.id && wrongIds.has(c.id));
  if(!list.length){
    alert("Aucune question marqu√©e comme fausse pour ce th√®me.");
    return;
  }
  reviewMode = true;
  cards = list;
  currentIndex = 0;
  state.showAnswer = false;
  updateReviewButtonLabel();
  render();
});

resetStatsBtn.addEventListener("click", ()=>{
  if(!currentThemeId) return;
  if(confirm("R√©initialiser la liste des questions fausses et le 'fait' pour ce th√®me ?")){
    wrongIds = new Set();
    doneIds = new Set();
    saveWrong();
    saveDone();

    if(reviewMode){
      reviewMode = false;
      updateReviewButtonLabel();
    }
    cards = fullCards.slice();
    currentIndex = 0;
    state.showAnswer = false;
    render();
  }
});

finishBtn.addEventListener("click", ()=>{
  window.scrollTo({ top: 0, left: 0, behavior: "smooth" });
  setTimeout(()=>{
    themeSelect.focus();
    alert("Th√®me termin√© ‚úÖ\nChoisis un autre th√®me en haut.");
  }, 250);
});

themeSelect.addEventListener("change", e=>loadTheme(e.target.value));

async function loadTheme(id){
  const t = THEMES_INDEX?.themes?.find(x=>x.id===id);
  if(!t){
    cards=[]; fullCards=[]; currentThemeId=null;
    qText.textContent="Th√®me introuvable.";
    render();
    return;
  }

  currentThemeId = id;
  reviewMode = false;
  updateReviewButtonLabel();

  loadWrong(id);
  loadDone(id);

  try{
    const r = await fetch(withBust(t.file), {cache:"no-store"});
    if(!r.ok) throw new Error("HTTP "+r.status);
    const data = await r.json();
    if(!Array.isArray(data.cards)) throw new Error("JSON invalide: cards manquant");

    fullCards = data.cards.slice();
    cards = fullCards.slice();
    currentIndex=0; state.showAnswer=false;
    hideMarkRow();

    render();
    setOfflineLabel(true);
  }catch(e){
    cards=[]; fullCards=[]; currentIndex=0; state.showAnswer=false;
    hideMarkRow();
    qText.textContent = `Erreur de chargement du th√®me: ${t.file}`;
    aText.textContent = String(e);
    aText.classList.remove("hidden");
    statsLine.textContent="‚Äî";
    hintLine.textContent="";
    setOfflineLabel(false);
  }
}

async function loadIndex(){
  try{
    const r = await fetch("themes/index.json", {cache:"no-store"});
    if(!r.ok) throw new Error("HTTP "+r.status);
    const idx = await r.json();
    if(!Array.isArray(idx.themes) || idx.themes.length===0) throw new Error("index.json invalide (themes vide)");
    if(!idx.version) throw new Error("index.json: champ 'version' manquant");

    THEMES_INDEX = idx;

    // Show ONLY the index.json version to user
    contentVersion.textContent = idx.version;

    // Use it for cache-busting too
    appVersion = idx.version;

    themeSelect.innerHTML = idx.themes.map(t=>`<option value="${t.id}">${t.name}</option>`).join("");
    await loadTheme(idx.themes[0].id);
    setOfflineLabel(true);

    // Register SW AFTER version is known (so bust works)
    if("serviceWorker" in navigator){
      navigator.serviceWorker.register(withBust("sw.js")).catch(()=>{});
    }
  }catch(err){
    console.error(err);
    setOfflineLabel(false);
    contentVersion.textContent = "ERREUR index.json";
    qText.textContent="Erreur de chargement (themes/index.json).";
    aText.textContent=String(err);
    aText.classList.remove("hidden");

    showAnswerBtn.classList.add("hidden");
    markRow.classList.add("hidden");
    skipBtn.classList.add("hidden");
    finishBtn.classList.add("hidden");
  }
}

loadIndex();
</script>
</body>
</html>
